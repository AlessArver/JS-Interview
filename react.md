1. **React** — это библиотека JavaScript для создания пользовательских интерфейсов, разработанная Facebook. Она позволяет создавать компоненты, которые управляют собственным состоянием и могут быть переиспользованы.
2. **JSX(JavaScript XML)** — это синтаксическое расширение для JavaScript, которое позволяет писать HTML код внутри JavaScript. JSX компилируется в вызовы React.createElement().
3. **Redux** — это библиотека для управления состоянием приложения, основанная на концепции единого хранилища (store), действий (actions) и редьюсеров (reducers).
4. Context
   1. Контекст разработан для передачи данных, которые можно назвать глобальными для всего дерева React-компонентов. Это позволяет избежать передачи пропсов в промежуточные компоненты.
5. Virtual DOM(VDOM)
   1. Это концепция программирования, в которой VDOM хранится в памяти и синхронизируется с DOM при помощи библиотеки, такой как ReactDOM.
   2. https://ru.legacy.reactjs.org/docs/faq-internals.html
6. Shadow DOM
   1. Благодаря ему в компоненте есть собственное теневое DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.
   2. https://learn.javascript.ru/shadow-dom
7. HOC
   1. Это функция, которая принимает компонент и возвращает новый.
8. `createPortal`
   1. `createPortal(children, domNode, key?)`
   2. Позволяет отобразить некоторые дочерние элементы в другом DOM узле.
9. Reconciliation
   1. Это алгоритм React, используемый для того, чтобы отличить одно дерево элементов от другого для определения частей, которые нужно будет заменить.
10. Обработка ошибок в React
    1. Классовый компонент Error Boundary
11. Оптимизация производительности
    1. Использование Profile вкладки в браузере для слежение за временм отрисовки компонентов.
    2. Использование библиотек для отрисовки только тех элементов списка, что есть во viewport.
    3. Ленивая загрузка изображений при помощи библиотек.
12. Hooks
    1. **useCallback**. Используется для мемоизации функций. Он принимает функцию и массив зависимостей, и возвращает мемоизированную версию функции.
    2. useMemo
    3. useEffect
    4. useLayoutEffect
    5. useId
    6. useReducer
    7. useRef
    8. useState
    9. useContext
13. Другие полезные функции в React
    1. `lazy()`. Позволяет отложить загрузку кода компонента до его первого отображения.
    2. `memo()`. Избегает повторного рендеринга компонента, если его пропсы не изменились.
    3. `forwardRef()`. Позволяет вашему компоненту передавать ref с помощью ссылки.
    4. `createContext()`.
14. Методы жизненного цикла в классовых компонентах:
    1. ComponentDidMount
    2. ComponentDidUpdate
    3. ComponentWillUnmount
    4. ShouldComponentUpdate
    5. GetDerivedStateFromProps
    6. GetSnapshotBeforeUpdate.
15. **ShouldComponentUpdate** определяет, должен ли компонент перерисовываться при изменении состояния или пропсов. Он возвращает булево значение.
16. **Concurrent Mode** — это экспериментальный режим в React, который позволяет улучшить отзывчивость приложений за счет прерывания рендеринга и выполнения задач с высоким приоритетом.

### React Context + useReducer

Плюсы:

1. Нет необходимости в дополнительных зависимостях.
2. Подходит для небольших приложений или отдельных частей состояния.
3. Легко интегрируется с TypeScript.
   Минусы:
4. Контекст может вызвать повторный рендер всех компонентов, которые его используют.
5. Могут возникнуть сложности при управлении большим и сложным состоянием.

### Redux

Плюсы:

1. Состояние хранится в одном месте, что облегчает отладку и тестирование.
2. Большое количество middleware и инструментов для разработки.
3. Хорошая интеграция с TypeScript.
   Минусы:
4. Может показаться слишком сложным для простых приложений.
5. Требует написания большого количества шаблонного кода (actions, reducers).

### MobX

Плюсы:

1. Автоматическое обновление компонентов при изменении состояния.
2. Меньше шаблонного кода по сравнению с Redux.
   Минусы:
3. Механизмы MobX могут быть менее прозрачны, что усложняет отладку.
4. Меньше инструментов и middleware по сравнению с Redux.

### Recoil

Плюсы:

1. Хорошо интегрируется с хуками и компонентами React.
2. Удобная работа с асинхронными данными через селекторы.
3. Состояние можно разбить на атомы и селекторы, что упрощает масштабирование.
4. Встроенная поддержка асинхронных операций.
   Минусы:
5. Меньшая зрелость и экосистема по сравнению с Redux или MobX.

### Zustand

Плюсы:

1. Легкий API, минимальное количество шаблонного кода.
2. Оптимизирован для минимального количества перерисовок.
3. Легко разделять состояние на логические части.
   Минусы:
4. Меньше инструментов и документации по сравнению с более популярными решениями.
5. Новая библиотека, которая еще не получила широкого распространения.

### Jotai

Плюсы:

1. Минимальный API, легкая интеграция с React.
2. Состояние разбивается на атомы, что упрощает управление и масштабирование.
3. Оптимизирован для минимальных перерисовок компонентов.
4. Встроенная поддержка асинхронных операций через атомы.
   Минусы:
5. Меньше инструментов и middleware по сравнению с более зрелыми решениями.
6. Меньшая зрелость и распространенность.

### Effector

Плюсы:

1. Позволяет описывать логику управления состоянием декларативно, что делает код более читаемым и поддерживаемым.
2. Позволяет автоматически обновлять компоненты при изменении состояния.
3. Оптимизирован для минимизации перерисовок компонентов.
4. Поддержка Typescript.
5. Встроенная поддержка асинхронных операций.
6. Предоставляет хорошие возможности для тестирования логики управления состоянием, что упрощает написание юнит-тестов.
   Минусы:
7. По сравнению с более популярными решениями, такими как Redux, у Effector меньшая экосистема и сообщество, что может ограничить доступность сторонних библиотек и инструментов.
