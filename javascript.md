1. Типы данных?
   1. number
   2. string
   3. boolean
   4. null
   5. undefined
   6. object
   7. symbol
   8. bigint
2. Примитивные типы данных.
   1. Примитивными типами являются все типы кроме object. Суть в том, что примитивы immutable(неизменяемы).
   2. Если написать: `let str = "Thi's string!"; str.toUpperCase(); console.log(str)`, то выведется: `"Thi's string!"`. Если сделать похожее с массивом: `let arr = []; arr.push("foo"); console.log(arr)`, то будет видно, что массив arr поменялся.
3. Что такое замыкания?
   1. Замыкание даёт вам доступ к области видимости внешней функции из внутренней функции.
4. Область видимости.
   1. Глобальная. Глобальные переменные доступны во всем приложении. Например, в JavaScript winddow и document являются глобальными объектами, предоставляемые браузером.
   2. Модульная.
   3. Блочная.
   4. Функциональная.
   5. Лексическая. Переменные из области видимости внешней функции доступны в области видимости вложенной функции
5. Методы массивов.

   1. `.map()`. Данный метод не изменяет массив, для которого он был вызван, данный метод создает новый массив.
   2. `.forEach()` выполняет функцию `callback` один раз для каждого элемента, находящегося в массиве
   3. `.reverse()`. `array.reduce(callback[, initialValue])`. Изменяет массив, меняя элементы местами(было: 1,2,3, стало: 3,2,1).
   4. `.reduce()`. Возвращаемое значение метода `.reduce()` - накопленный результат со всех вызовов `callback` для каждого элемента.
   5. `.reduceRight()`. Возвращаемое значение метода `.reduce()` - накопленный результат со всех вызовов `callback` для каждого элемента слева направо.
   6. `.unshift()`. добавляет один или более элементов в начало массива и возвращает новую длину массива.
   7. .`shift()`. Удаляет первый элемент из массива и возвращает его значение
   8. **`push()`**. Добавляет один или более элементов в конец массива и возвращает новую длину массива.
   9. **`.pop()`**. Удаляет **последний** элемент из массива и возвращает его значение.
   10. **`.slice()`**. Возвращает новый массив, содержащий копию части исходного массива.
   11. `Array.isArray()`. Возвращает `true`, если объект является массивом.
   12. `.splice()`. Удаляет существующие элементы и/или добавляет новые.

   ```
      var myFish = ["angel", "clown", "mandarin", "sturgeon"];
      var removed = myFish.splice(2, 0, "drum");
      // myFish равен ["angel", "clown", "drum", "mandarin", "sturgeon"]
      // removed равен [], ничего не удалено
   ```

   9. `.sort()`. Сортирует элементы массива и возвращает отсортированный массив.
   10. `.some()`. Проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.
   11. **`.every()`**. Проверяет, удовлетворяют ли все элементы массива условию
   12. **`.indexOf()`**. Возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.
   13. **`.flat()`**. Возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень depth.

   ```
      var arr1 = [1, 2, [3, 4]];
      arr1.flat();
      // [1, 2, 3, 4]
   ```

   13. **`Array.from()`** создаёт новый экземпляр `Array`.
   14. **`.find()`**. Возвращает **значение** первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции
   15. **`fill()`**. Заполняет все элементы массива от начального до конечного индексов одним значением.

6. Методы промисов
   1. `.all()`. В случае, если любой из промисов будет отклонён, `Promise.all` будет также отклонён.
   2. `.race()`. В отличие от `Promise.all`, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.
   3. `.allSettled()`. Ожидает завершения всех полученных промисов (как исполнения так и отклонения).
   4. `.reject()`. Возвращает отклонённый промис.
   5. `.resolve()`. Возвращает исполненный промис.
7. Состояния промисов
   1. Pending - операция стартовала
   2. Fulfiled - получен результат
   3. Rejected - ошибка
8. Что такое всплытие события?
   1. Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.
9. Что такое погружение события?
   1. Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков.
10. Что такое event loop?
    1. Сначала Event Loop проверяет выполнились ли все синхронные задачи
    2. Потом выполняются все задачи из микротасков
    3. После выполнения всех микротасков - очередь очищается
    4. Затем мы берем одну макрозадачу из списка и выполняем ее
    5. После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
    6. Если перерисовать страницу нужно - делаем это
    7. Все снова начинается с первого пункта
    8. https://habr.com/ru/articles/762618/
11. В чем разница между методами event.preventDefault() и event.stopPropagation()?
    1. Метод event.preventDefault() отключает поведение элемента по умолчанию. Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).
12. `event.currentTarget` или `event.target`?
    1. `event.currentTarget` определяет элемент, в котором в данный момент обрабатывается событие, при движении события внутри DOM. `event.target` - идентифицирует элемент, на котором событие возникло.
13. Для чего используется оператор "!!"
    1. Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.
14. Что такое NaN?
15. Для чего используется директива «use strict»?
    1. Нельзя присваивать значения или обращаться к необъявленным переменным.
    2. Запрещено присваивать переменным названия как: NaN, undefined, Infinity и др.
    3. Нельзя дублировать параметры в функции: `function(a, b, b, c) {...}`
16. Отличие `.bind()`, `.call()`, `.apply()`.
    1. `.bind()` Создает новую функцию с заданным контекстом this.
    2. `.call(this, name, price, age, ...)`
    3. `.apply(this, [name, price, age, ...])`
17. Разница между стрелочными функциями
    1. У стрелочных нет arguments
    2. Значение `this` внутри стрелочной функции всегда эквивалентно значения *this* внешней функции
18. Клонирование объектов

    1. JSON.parse(obj)
    2. structuredClone(obj). Глубокое клонирование. Доступно в 17 версии node
    3. Object.assign({}, obj). Поверхностное клонирование
    4. Object.create(obj). Поверхностное клонирование
    5. Если выполнено не полное копирование, то это значит, что:

    ```
    const personObj = { name: "Alice", bithDay: new Date(123), friends: ["Masha"] }         const shallowCopy = {...calendarEvent}
    // "Bob" добавили и к копии и оригиналу                                                 shallowCopy.friends.push("Bob")
    // Время изменили время и у клона и оригинала
    ```

    Произойдет это из-за того, что при неполном копировании shallowCopy имеет ссылку на массив friends, а не новый массив friends.

    Так же можно самому написать функцию глубокого копирования:

    ```
    const deepClone = (obj) => {
    	if (obj === null) return null
    	const clone = Object.assign({}, obj)
    	Object.keys(clone).forEach( (key) => (
    	clone[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]
    	) )
    	if (Array.isArray(obj)) {
    		clone.length = obj.length return Array.from(clone)
    	}
    	return clone
    }
    const a = { foo: 'bar', obj: { a: 1, b: 2 } }
    const b = deepClone(a) // a !== b = true, a.obj === b.obj = false
    ```

    https://habr.com/p/729434/

19. Что в `structuredClone` нельзя клонировать?
    1. Функции. Они будут генерировать DataCloneError исключение.
    2. DOM-узлы. Также выдает DataCloneError исключение.
    3. Сеттеры и геттеры
    4. Прототипы объектов
20. `Set()`
    1. Уникальная коллекция значений.
21. `Map()`
    1. Это коллекция ключ/значение, как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа.
22. Деструктуризация
    1. Это синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части. Пример: `let [firstName, lastName] `=` ["Илья", "Кантор"];`
23. Как узнать, что блок(например div) в области видимости window?
    1. Intersection Observer. Позволяет приложению асинхронно наблюдать за пересечением элемента (target) с его родителем (root) или областью просмотра (viewport). Источник: https://habr.com/ru/articles/494670/
24. Транспилятор
    1. Преобразование программы, представленной на одном из языков программирования, в программу, написанную на другом языке или другой версии того же языка программирования.
25. Хранение данных в браузере
    1. Cookies, local storage, session storage, index db
26. Cookies
    1. Чтение, запись, время жизни.
    2. Можно использовать samesite для защиты от XSRF атак.
    3. httpOnly для запрета работы с кукой на JavaScript
    4. Подробнее: https://learn.javascript.ru/cookie
